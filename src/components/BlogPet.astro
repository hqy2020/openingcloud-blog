---
/**
 * BlogPet.astro — 固定驻留版 oneko
 * Base logic: https://github.com/adryd325/oneko.js (MIT)
 * Sprite asset: https://github.com/kyrie25/spicetify-oneko (MIT)
 */
---

<script is:inline>
(function blogPet() {
  const PET_ID = 'blog-pet';
  const STYLE_ID = 'blog-pet-style';
  const previous = window.__blogPetState;
  if (previous && typeof previous.cleanup === 'function') {
    previous.cleanup();
  }
  const state = {
    timer: 0,
    cleanup: null,
  };
  window.__blogPetState = state;

  const reduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  const PET_SIZE = 32;
  const HALF = PET_SIZE / 2;
  const PET_SPEED = 10;
  const PET_SCALE = window.innerWidth < 768 ? 1.45 : 1.8;

  const spriteSets = {
    idle: [[-3, -3]],
    alert: [[-7, -3]],
    scratchSelf: [[-5, 0], [-6, 0], [-7, 0]],
    scratchWallN: [[0, 0], [0, -1]],
    scratchWallS: [[-7, -1], [-6, -2]],
    scratchWallE: [[-2, -2], [-2, -3]],
    scratchWallW: [[-4, 0], [-4, -1]],
    tired: [[-3, -2]],
    sleeping: [[-2, 0], [-2, -1]],
    N: [[-1, -2], [-1, -3]],
    NE: [[0, -2], [0, -3]],
    E: [[-3, 0], [-3, -1]],
    SE: [[-5, -1], [-5, -2]],
    S: [[-6, -3], [-7, -2]],
    SW: [[-5, -3], [-6, -1]],
    W: [[-4, -2], [-4, -3]],
    NW: [[-1, 0], [-1, -1]],
  };

  function ensureStyle() {
    if (document.getElementById(STYLE_ID)) return;
    const style = document.createElement('style');
    style.id = STYLE_ID;
    style.textContent = `
      #${PET_ID} {
        position: fixed;
        width: ${PET_SIZE}px;
        height: ${PET_SIZE}px;
        pointer-events: auto;
        user-select: none;
        image-rendering: pixelated;
        z-index: 9998;
        background-repeat: no-repeat;
        background-size: 256px 128px;
        filter: drop-shadow(0 8px 12px rgba(15, 23, 42, 0.28));
        transform-origin: center center;
        transform: scale(var(--pet-scale, 1.8)) translateY(0);
        cursor: pointer;
      }
      #${PET_ID}.is-animated {
        animation: blog-pet-float 2.8s ease-in-out infinite;
      }
      #${PET_ID}:active {
        transform: scale(calc(var(--pet-scale, 1.8) * 0.96)) translateY(0);
      }
      @keyframes blog-pet-float {
        0%, 100% { transform: scale(var(--pet-scale, 1.8)) translateY(0); }
        50% { transform: scale(var(--pet-scale, 1.8)) translateY(-3px); }
      }
      @media (max-width: 767px) {
        #${PET_ID} {
          --pet-scale: 1.45;
        }
      }
    `;
    document.head.appendChild(style);
  }

  function ensurePet() {
    let pet = document.getElementById(PET_ID);
    if (!pet) {
      pet = document.createElement('div');
      pet.id = PET_ID;
      pet.ariaHidden = true;
      document.body.appendChild(pet);
    }
    pet.innerHTML = '';
    pet.style.backgroundImage = "url('/pets/oneko-sheep.png')";
    pet.style.backgroundPosition = '0px 0px';
    pet.style.setProperty('--pet-scale', String(PET_SCALE));
    return pet;
  }

  function setSprite(pet, name, frame) {
    const row = spriteSets[name];
    if (!row) return;
    const sprite = row[frame % row.length];
    pet.style.backgroundPosition = sprite[0] * 32 + 'px ' + sprite[1] * 32 + 'px';
  }

  function startIdleLoop(pet) {
    let nekoPosX = Math.max(HALF, window.innerWidth - 54);
    let nekoPosY = Math.max(HALF, window.innerHeight - 54);
    let mousePosX = nekoPosX;
    let mousePosY = nekoPosY;
    let frameCount = 0;
    let idleTime = 0;
    let idleAnimation = null;
    let idleAnimationFrame = 0;
    let forceSleep = false;
    let lastClickTs = 0;

    function setPosition() {
      pet.style.left = `${nekoPosX - HALF}px`;
      pet.style.top = `${nekoPosY - HALF}px`;
    }

    setPosition();

    function resetIdleAnimation() {
      idleAnimation = null;
      idleAnimationFrame = 0;
    }

    function idle() {
      idleTime += 1;

      if (idleTime > 10 && Math.floor(Math.random() * 200) === 0 && idleAnimation === null) {
        const available = ['sleeping', 'scratchSelf'];
        if (nekoPosX < 40) available.push('scratchWallW');
        if (nekoPosY < 40) available.push('scratchWallN');
        if (nekoPosX > window.innerWidth - 40) available.push('scratchWallE');
        if (nekoPosY > window.innerHeight - 40) available.push('scratchWallS');
        idleAnimation = available[Math.floor(Math.random() * available.length)];
      }

      if (forceSleep) {
        idleAnimation = 'sleeping';
      }

      switch (idleAnimation) {
        case 'sleeping':
          if (idleAnimationFrame < 8) {
            setSprite(pet, 'tired', 0);
            break;
          }
          setSprite(pet, 'sleeping', Math.floor(idleAnimationFrame / 4));
          if (idleAnimationFrame > 180) resetIdleAnimation();
          break;
        case 'scratchWallN':
        case 'scratchWallS':
        case 'scratchWallE':
        case 'scratchWallW':
        case 'scratchSelf':
          setSprite(pet, idleAnimation, idleAnimationFrame);
          if (idleAnimationFrame > 9) resetIdleAnimation();
          break;
        default:
          setSprite(pet, 'idle', 0);
          return;
      }

      idleAnimationFrame += 1;
    }

    function step() {
      frameCount += 1;

      if (forceSleep) {
        idle();
        return;
      }

      const diffX = nekoPosX - mousePosX;
      const diffY = nekoPosY - mousePosY;
      const distance = Math.sqrt(diffX * diffX + diffY * diffY);

      if (distance < PET_SPEED || distance < 48) {
        idle();
        return;
      }

      idleAnimation = null;
      idleAnimationFrame = 0;

      if (idleTime > 1) {
        setSprite(pet, 'alert', 0);
        idleTime = Math.min(idleTime, 7);
        idleTime -= 1;
        return;
      }

      let direction = '';
      direction = diffY / distance > 0.5 ? 'N' : '';
      direction += diffY / distance < -0.5 ? 'S' : '';
      direction += diffX / distance > 0.5 ? 'W' : '';
      direction += diffX / distance < -0.5 ? 'E' : '';
      if (direction) setSprite(pet, direction, frameCount);

      nekoPosX -= (diffX / distance) * PET_SPEED;
      nekoPosY -= (diffY / distance) * PET_SPEED;

      nekoPosX = Math.min(Math.max(HALF, nekoPosX), window.innerWidth - HALF);
      nekoPosY = Math.min(Math.max(HALF, nekoPosY), window.innerHeight - HALF);
      setPosition();
    }

    function onMouseMove(e) {
      if (forceSleep) return;
      mousePosX = e.clientX;
      mousePosY = e.clientY;
    }

    function onWindowClick(e) {
      if (forceSleep) return;
      mousePosX = e.clientX;
      mousePosY = e.clientY;
      idleTime = 0;
      setSprite(pet, 'alert', 0);
    }

    function onPetClick(e) {
      e.stopPropagation();
      const now = Date.now();
      if (now - lastClickTs < 280) {
        forceSleep = !forceSleep;
        resetIdleAnimation();
        idleTime = 0;
        if (!forceSleep) {
          mousePosX = window.innerWidth - 32;
          mousePosY = window.innerHeight - 32;
        }
      } else {
        setSprite(pet, 'alert', 0);
      }
      lastClickTs = now;
    }

    function onResize() {
      nekoPosX = Math.min(Math.max(HALF, nekoPosX), window.innerWidth - HALF);
      nekoPosY = Math.min(Math.max(HALF, nekoPosY), window.innerHeight - HALF);
      setPosition();
    }

    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('click', onWindowClick);
    window.addEventListener('resize', onResize);
    pet.addEventListener('click', onPetClick);

    if (state.timer) {
      clearInterval(state.timer);
      state.timer = 0;
    }

    if (reduced) {
      // 减少动态偏好下保留交互，但停掉漂浮
      pet.classList.remove('is-animated');
    } else {
      pet.classList.add('is-animated');
    }

    // 首帧提醒
    setSprite(pet, 'alert', 0);
    setTimeout(() => setSprite(pet, 'idle', 0), 240);

    state.timer = window.setInterval(() => {
      if (document.hidden) return;
      step();
    }, 100);

    state.cleanup = () => {
      if (state.timer) {
        clearInterval(state.timer);
        state.timer = 0;
      }
      window.removeEventListener('mousemove', onMouseMove);
      window.removeEventListener('click', onWindowClick);
      window.removeEventListener('resize', onResize);
      pet.removeEventListener('click', onPetClick);
    };
  }

  ensureStyle();
  const pet = ensurePet();
  startIdleLoop(pet);
})();
</script>
