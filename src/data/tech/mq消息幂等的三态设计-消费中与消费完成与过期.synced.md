---
title: "MQ消息幂等的三态设计-消费中与消费完成与过期"
description: "为什么两态不够？消费中→消费完成/过期删除的三态幂等设计方案"
date: 2026-02-10
category: tech
tags: [Java, RocketMQ, 幂等, 消息队列, Redis]
---

# MQ消息幂等的三态设计-消费中与消费完成与过期

## 定义
> 消息幂等不能只区分"消费过/没消费过"两种状态，还需要引入"消费中"状态。三态设计（消费中 → 消费完成 / 过期删除）才能同时解决并发重复消费和消费者崩溃两个问题。

## 核心要点

### 为什么两态不够
RocketMQ 保证 "at least once"（至少消费一次），**不保证不重复投递**。两条相同消息可能并发到达：
- 如果只有"已消费"标记，两条消息都发现"未消费"，都开始执行，导致重复消费
- 分布式锁能防并发，但锁释放后第二条消息仍会执行

### 三态设计方案
1. **消费中**：用 Redis `SET NX`（原子操作）写入幂等 Key + 10分钟过期时间
2. **消费完成**：业务逻辑执行成功后，更新 Key 的值为"已完成"并去掉 TTL
3. **过期删除**：如果消费中途崩溃，10分钟后 Key 自动过期，后续消息可以重新消费

### 并发场景的处理
- 消息A成功 SET NX → 开始消费 → 消费完成 → 标记已完成
- 消息B SET NX 失败 → 发现状态是"消费中" → 抛异常触发 RocketMQ 延迟重试
- 消息B重试时发现状态是"消费完成" → 直接返回成功（幂等）

### 封装为通用组件
通过 `@MessageIdempotent` 注解 + AOP 切面，将幂等逻辑抽取为 framework 通用组件，业务代码零侵入。

## 与其他概念的关系
- [AOP+注解封装通用组件的套路](/posts/aop注解封装通用组件的套路)：幂等组件和防重复提交组件用的是同一套封装模式
- [MQ削峰填谷的本质是转移等待者](/posts/mq削峰填谷的本质是转移等待者)：MQ 保证不丢但可能重复，幂等是与之配套的防重机制
- [v2异步方案的一致性保障机制](/posts/v2异步方案的一致性保障机制)：v2 异步消费中必须有幂等保障

## 应用场景
- 面试被问"MQ 消息重复消费怎么处理"：先说 at least once 的本质，再说三态设计
- 面试追问"消费中途崩溃怎么办"：TTL 过期机制保障消息可以被重新消费

## 参考来源
- [第22小节-基于注解实现去重表消息防止重复消费](/posts/第22小节-基于注解实现去重表消息防止重复消费)
