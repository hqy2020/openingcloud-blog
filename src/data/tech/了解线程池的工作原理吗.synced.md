---
title: "了解线程池的工作原理吗"
description: "线程池基于生产者-消费者模型，含Worker、WorkQueue、状态机三大核心组件"
date: 2026-02-11
category: tech
tags: [并发编程]
---

# 了解线程池的工作原理吗？

## 回答话术

线程池基于生产者-消费者模型，由三部分组成：线程池本体（维护运行状态、管理工作线程、调度任务）、工作队列（缓冲任务的阻塞队列）、工作线程（持有 Thread 对象的 Worker 内部类）。

**任务提交流程**：
1. 工作线程数 < 核心线程数 -> 启动新线程
2. 工作线程数 >= 核心线程数 && 队列未满 -> 加入队列
3. 工作线程数 >= 核心线程数 && 队列已满 -> 启动非核心线程
4. 达到最大线程数 && 队列已满 -> 触发拒绝策略

工作线程在 while 循环中不断从队列获取任务，执行前后调用回调方法，超时未获取任务则退出。

## 问题详解

### 1. 实现体系

```
Executor（顶级接口）
  -> ExecutorService（添加submit/shutdown方法）
    -> AbstractExecutorService（统一submit实现）
      -> ThreadPoolExecutor（核心实现）
```

### 2. 构造函数七大参数

| 参数 | 说明 |
|-----|------|
| corePoolSize | 长期存在的核心线程数 |
| maximumPoolSize | 最大线程总数 |
| keepAliveTime | 非核心线程闲置存活时间 |
| unit | 时间单位 |
| workQueue | 任务缓冲的阻塞队列 |
| threadFactory | 创建线程的工厂 |
| handler | 队列满时的拒绝策略 |

### 3. Worker 工作线程结构

Worker 继承 AQS 并实现 Runnable 接口，包含：
- `Thread thread`：实际执行线程
- `Runnable firstTask`：首个执行任务
- `volatile long completedTasks`：完成任务计数
- 状态初始为 -1（禁止中断），启动后改为 0（允许中断）

### 4. 状态控制机制

**ctl（AtomicInteger）**：32位整数，高3位记录线程状态，低29位记录线程数。

五种状态（按优先级）：
- `RUNNING`（-1左移29位）：运行，接受新任务
- `SHUTDOWN`（0）：关闭，不接受新任务，处理完剩余任务
- `STOP`（1左移29位）：停止，中断所有任务
- `TIDYING`（2左移29位）：整理，队列空且无工作线程
- `TERMINATED`（3左移29位）：终止，彻底停止

状态流转：`RUNNING -> SHUTDOWN -> TIDYING -> TERMINATED` 或 `RUNNING -> STOP -> TIDYING -> TERMINATED`

### 5. 任务提交流程（execute 方法）

```java
public void execute(Runnable command) {
    int c = ctl.get();
    // 阶段1：工作线程数 < 核心线程数
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true)) return;
    }
    // 阶段2：队列未满，加入队列
    if (isRunning(c) && workQueue.offer(command)) {
        // 双重检查：若线程池停止则移除任务
        // 若无工作线程则创建一个
    }
    // 阶段3：队列已满，创建非核心线程
    else if (!addWorker(command, false))
        reject(command);  // 阶段4：触发拒绝策略
}
```

### 6. 工作线程执行流程（runWorker 方法）

```
while (task != null || (task = getTask()) != null) {
    1. 加锁（防止shutdown时中断运行任务）
    2. 检查线程状态，必要时中断
    3. 调用beforeExecute回调
    4. 执行task.run()（异常被捕获）
    5. 调用afterExecute回调
    6. 解锁，统计完成任务数
    7. 回到步骤1获取下一个任务
}
-> getTask超时或异常 -> processWorkerExit（线程退出）
```

### 7. 停机流程

**shutdown 方法**（正常关闭）：改状态为 SHUTDOWN，中断所有空闲工作线程，等待现存任务完成。

**shutdownNow 方法**（立即停止）：改状态为 STOP，中断所有工作线程，清空任务队列，返回未执行任务列表。

**真正停机（tryTerminate）**：最后一个线程退出时，状态改为 TIDYING -> 执行 terminated() 回调 -> 状态改为 TERMINATED。

### 8. 默认拒绝策略

| 策略 | 行为 |
|-----|------|
| AbortPolicy | 抛出 RejectedExecutionException（默认） |
| CallerRunsPolicy | 由提交线程执行任务 |
| DiscardOldestPolicy | 移除队列最前任务，加入新任务 |
| DiscardPolicy | 直接丢弃新任务 |

## 关键要点

- 生产者-消费者模型：任务生产与执行解耦
- 三层队列：核心线程直接执行 -> 阻塞队列缓冲 -> 非核心线程执行
- 线程复用：Worker 循环从队列获取任务，避免重复创建销毁
- 状态机精妙：ctl 用高3位低29位编码状态和线程数，单个原子变量管理复杂状态
- 分层同步：mainLock 管全局，AQS 管单个线程，避免过度锁定
- 双重检查：offer() 后 recheck，防止竞态条件
- 优雅关闭：shutdown 等待完成，shutdownNow 强制中断，tryTerminate 延迟停机
