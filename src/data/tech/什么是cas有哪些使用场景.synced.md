---
title: "什么是CAS有哪些使用场景"
description: "CAS原子操作原理及在自旋锁、乐观锁、原子类中的应用"
date: 2026-02-11
category: tech
tags: [并发编程]
---

# 什么是 CAS？有哪些使用场景？

## 回答话术

CAS（Compare And Swap）是一种原子性操作，包含三个步骤：获取变量旧值、检查是否等于预期值、相等时替换为新值。在多线程环境中，线程通过循环进行 CAS 操作直到成功，形成自旋锁机制。由于 CAS 由 CPU 硬件直接支持且避免上下文切换，在锁竞争激烈且持有时间短的场景下，相比 synchronized 更高效。CAS 还广泛应用于数据库乐观锁，通过版本号比较实现并发控制。其主要问题是 ABA 问题，可通过版本号递增来解决。

## 问题详解

### CAS 的基本原理

CAS 描述的操作序列：
1. 从内存地址获取变量 V 的旧值
2. 检查旧值 V 是否等于预期值 A
3. 若相等，则替换为新值 B

### 实现机制

- **Unsafe 类**：JUC 包通过 Unsafe 的 `compareAndSwapInt` 等 native 方法进行 CAS
- **内存地址获取**：提前通过 `objectFieldOffset` 获取属性的内存地址
- **原子性保证**：JVM 调用底层本地方法，CPU 指令前加 LOCK 前缀锁定系统总线

### 自旋锁机制

自旋锁通过 CAS + 循环实现：
- 线程反复尝试 CAS 修改目标变量
- 成功者获得"锁"，失败者继续自旋
- 避免线程阻塞，无上下文切换开销
- 代价是占用更多 CPU 资源

### 可见性保证

被 CAS 修改的变量需加 `volatile` 修饰，否则线程读写各自工作内存副本，互相隔离，多个线程可同时成功 CAS，违反预期。

### 乐观锁应用

**数据库方案**：

```sql
UPDATE example t
SET t.name = ${name}, t.version = t.version + 1
WHERE t.id = ${id} AND t.version = ${version}
```

**业务层自旋重试**：查询最新版本号 -> 修改数据后尝试更新 -> 失败时循环重试，成功时返回。

### 监视器锁 vs 自旋锁

- **重量级锁**（synchronized）：竞争失败进入阻塞，涉及上下文切换
- **自旋锁**：线程保持运行，不释放 CPU 时间片，适合短持有场景

## 关键要点

- CAS 由 X86 处理器 LOCK 前缀指令在硬件层面实现原子性
- 应用场景：自旋锁、乐观锁、AtomicInteger 等原子类
- 优势：高效（无上下文切换）、灵活
- 劣势：CPU 占用高、存在 ABA 问题
- volatile 保证变量修改的线程间可见性，是 CAS 正确工作的前提
- AQS 框架：JUC 下大部分 Lock 实现都基于 AQS（基于 CAS + 自旋）
- JDK8 synchronized 已引入锁升级机制：偏向锁 -> 自旋锁 -> 重量级锁
