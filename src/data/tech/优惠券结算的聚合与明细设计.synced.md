---
title: "优惠券结算的聚合与明细设计"
description: "优惠券结算需要同时携带订单级聚合数据和商品级明细数据，因为不同券的作用域不同"
date: 2026-02-11
category: tech
tags: [业务设计, 电商, 优惠券]
---

# 优惠券结算的聚合与明细设计

## 定义
> 优惠券结算接口的请求参数必须同时包含订单级聚合信息（总金额、店铺）和商品级明细信息（每件商品的编号和金额），因为全店券看订单总金额，商品专属券看单品金额。

## 核心要点

### 请求参数结构

```java
public class QueryCouponsReqDTO {
    private BigDecimal orderAmount;                 // 聚合：订单总金额（一个）
    private String shopNumber;                      // 聚合：店铺编号（一个）
    private List<QueryCouponGoodsReqDTO> goodsList; // 明细：商品列表（多个）
}
```

一次只在一家店下一单（所以店铺和总金额只有一个），但一单可以买多件商品（所以商品是 List）。

### 不同券类型看不同金额

| 券类型 | 作用域 | 判断金额 | 举例 |
|--------|--------|---------|------|
| 全店券（goods 为空） | 整个订单 | `orderAmount` | 订单满100减10 |
| 商品专属券（goods = "001"） | 单个商品 | 该商品的 `goodsAmount` | 商品001满50减5 |

### 三种券的计算逻辑

```
立减券（type=0）：无门槛，直接减 maximumDiscountAmount
满减券（type=1）：金额 >= termsOfUse → 减 maximumDiscountAmount
折扣券（type=2）：金额 >= termsOfUse → 减 min(金额×discountRate, maximumDiscountAmount)
```

折扣券有「封顶」机制：实际折扣和最大优惠取较小值。

### BigDecimal 比较用 compareTo

Java 中金额用 `BigDecimal` 表示（避免浮点精度问题），比较大小不能用 `>=`，必须用 `compareTo()`：

```java
// orderAmount >= termsOfUse ?
if (orderAmount.compareTo(termsOfUse) >= 0) { /* 可用 */ }
```

| 返回值 | 含义 |
|--------|------|
| `-1` | 小于 |
| `0` | 等于 |
| `1` | 大于 |
| `>= 0` | 大于等于 |

### 最终排序

可用券按优惠金额**降序**排列（优惠力度最大的排最前面），与美团、淘宝等业内标准一致：

```java
availableCouponList.sort((c1, c2) -> c2.getCouponAmount().compareTo(c1.getCouponAmount()));
```

## 与其他概念的关系
- [Redis Pipeline-批量命令减少网络往返](/posts/redis-pipeline-批量命令减少网络往返)：结算前先用 Pipeline 批量获取券模板详情
- [Collectors.toMap-List转Map的空间换时间](/posts/collectorstomap-list转map的空间换时间)：商品专属券计算前先将商品列表转为 Map 索引
- [ZSet数据结构-排序集合的设计精髓](/posts/zset数据结构-排序集合的设计精髓)：用户优惠券列表存储在 Redis ZSet 中

## 应用场景
- 订单结算页展示可用/不可用优惠券
- 优惠券自动推荐（按减免金额排序取第一个）
- 多券叠加计算（在此基础上扩展）

## 参考来源
- 《牛券oneCoupon优惠券系统设计》第29小节
