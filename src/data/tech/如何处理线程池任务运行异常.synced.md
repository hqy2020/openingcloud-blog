---
title: "如何处理线程池任务运行异常"
description: "UncaughtExceptionHandler、try-catch、Future.get三种异常处理方式"
date: 2026-02-11
category: tech
tags: [并发编程]
---

# 如何处理线程池任务运行异常？

## 回答话术

线程池执行任务时，异常不会传播到提交线程，而由线程池内部处理。异常线程被销毁后，线程池会创建新线程替代，以保持线程数量稳定。主要处理方案：

1. **try-catch 捕获**：在任务代码中直接捕获异常
2. **Future 处理**：使用 `submit()` 提交时，异常被包装在 Future 中，调用 `get()` 时抛出 ExecutionException
3. **UncaughtExceptionHandler**：在线程工厂中指定异常拦截器，推荐用于统一处理

## 问题详解

### 异常日志产生机制

线程池内部的异常处理流程：

```java
beforeExecute(wt, task);
try {
    task.run();
    afterExecute(task, null);
} catch (Throwable ex) {
    afterExecute(task, ex);
    throw ex;  // 向上抛出
}
```

异常被向上抛出后，JVM 调用 `Thread#dispatchUncaughtException` 方法，最终由 `UncaughtExceptionHandler` 接收。若未指定处理器，使用默认的 `ThreadGroup` 处理策略，最终通过 `System.err.print()` 打印异常堆栈。

### 三种异常处理方式

**方式一：线程工厂中指定 UncaughtExceptionHandler**

```java
ThreadFactory threadFactory = new ThreadFactory() {
    @Override
    public Thread newThread(Runnable r) {
        Thread t = Executors.defaultThreadFactory().newThread(r);
        t.setUncaughtExceptionHandler((thread, throwable) -> {
            System.out.println("Thread " + thread.getName()
                + " threw exception: " + throwable);
        });
        return t;
    }
};
ExecutorService executorService =
    Executors.newFixedThreadPool(1, threadFactory);
executorService.execute(() -> {
    int i = 1 / 0;  // ArithmeticException
});
```

**方式二：try-catch 捕获**

在任务代码中主动捕获，可根据异常类型决定重试、记录日志或告警。

**方式三：Future.get() 捕获**

```java
Future<?> future = executorService.submit(() -> {
    int i = 1 / 0;
});
try {
    future.get();
} catch (ExecutionException e) {
    // 处理任务执行中的异常
}
```

## 关键要点

- 异常隔离：线程池任务异常不会传播到提交线程
- 线程补偿：异常线程销毁后自动创建新线程替代
- 日志来源：由 JVM 的 UncaughtExceptionHandler 打印
- 推荐方案：在线程工厂中设置 UncaughtExceptionHandler 进行统一处理
- submit() 特性：异常被包装在 Future 中，需主动调用 get() 才能获取
