---
title: "线程池如何实现线程复用和回收"
description: "通过runWorker循环取任务实现复用，getTask超时机制回收非核心线程"
date: 2026-02-11
category: tech
tags: [并发编程]
---

# 线程池如何实现线程复用和回收？

## 回答话术

**线程复用**：线程池通过 `runWorker` 方法中的 while 循环实现复用。线程完成任务后不直接销毁，而是不断从阻塞队列中拿到新的任务并运行。只要队列中有任务，该线程就会继续执行。

**线程超时回收**：通过 `getTask` 方法的两种获取策略实现。核心线程使用 `take()` 无超时阻塞等待；非核心线程使用 `poll(keepAliveTime)` 超时等待，超时返回 null 后线程退出销毁。

## 问题详解

### 1. 线程复用原理

```java
while (task != null || (task = getTask()) != null) {
    // 执行任务
    task.run();
    // 循环继续获取下一个任务
}
```

通过该机制保障了在满足工作线程不销毁的前提下，让工作线程不断从阻塞队列中拿到新的任务并运行。

### 2. 超时回收决策逻辑

**判断是否需要超时**：

```java
boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
```

- 当工作线程数 > 核心线程数时，多余线程需要超时回收
- `allowCoreThreadTimeOut` 为 true 时，核心线程也可超时回收

**获取任务方式**：

```java
Runnable r = timed ?
    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :  // 有超时
    workQueue.take();  // 无超时
```

### 3. 阻塞队列获取方法对比

| 方法 | 特性 |
|------|------|
| take() | 无限期阻塞，直到获取元素 |
| poll(timeout) | 阻塞指定时间，超时返回 null |

若 poll 超时返回 null，getTask 返回空，while 循环结束，执行 `processWorkerExit` 销毁线程。

### 4. 线程销毁流程

`processWorkerExit` 方法处理两类退出场景：

**异常退出（completedAbruptly=true）**：
- 立即减少工作线程计数
- 立刻添加新工作线程补偿

**超时退出（completedAbruptly=false）**：
- 根据核心线程设置判断是否需要补偿
- 若允许核心线程超时且队列为空则不补偿
- 若不允许核心线程超时且线程数未达核心数则补偿

## 关键要点

- 复用的本质：Worker 对象的 thread 属性在 while 循环中反复调用 getTask 和 task.run()
- 超时回收判断：通过比较当前工作线程数与核心线程数来决定是否需要超时
- 两种获取模式：take（核心线程无限等待）、poll（非核心线程 keepAliveTime 后返回 null）
- 兜底策略：processWorkerExit 中的 addWorker(null, false) 确保线程池不会被意外清空
- keepAliveTime=0 会导致线程立即被回收，频繁创建销毁，不利于线程复用
- 防止线程回收：设置 corePoolSize == maximumPoolSize，所有线程都视为核心线程
