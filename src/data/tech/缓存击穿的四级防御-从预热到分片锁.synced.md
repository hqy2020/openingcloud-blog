---
title: "缓存击穿的四级防御-从预热到分片锁"
description: "层层递进的缓存击穿防御体系：预防层→标准层→体验层→性能层"
date: 2026-02-10
category: tech
tags: [Java, Redis, 缓存, 高并发, 分布式锁]
---

# 缓存击穿的四级防御-从预热到分片锁

## 定义
> 缓存击穿不是一招能解决的问题，而是需要层层递进的防御体系。从预热永不过期（预防层），到双重判定锁（标准层），到 tryLock 快速失败（体验层），再到分片锁（性能层），每一级解决前一级遗留的问题。

## 核心要点

### 第一级：预热 + 永不过期（预防层）
活动开始前预加载热点数据到 Redis，TTL 设为 -1。活动结束后由后台任务设置过期时间释放内存。**这是基础防线**，能覆盖大部分场景。

### 第二级：双重判定锁（标准层）
缓存未命中时先加分布式锁，获锁后**再查一次缓存**（第二次判定）。如果第一个请求已经回填了缓存，后续请求直接用缓存返回，避免重复查库。

### 第三级：tryLock 快速失败（体验层）
双重判定锁的问题：1万个请求排队，最后一个要等 10049ms。用 `tryLock` 代替 `lock`，拿不到锁直接返回"请稍后再试"。**宁可让用户重试，也不让请求在服务端排队**。

### 第四级：分片锁（性能层）
单个锁导致所有请求串行。将 key 通过 hash 分成多个分片，每个分片一把锁，多个请求可以并行回填不同分片的数据。

## 与其他概念的关系
- [缓存穿透的组合拳-布隆过滤器+空值缓存+分布式锁](/posts/缓存穿透的组合拳-布隆过滤器空值缓存分布式锁)：击穿是"有数据但缓存过期"，穿透是"数据本身不存在"
- [v1与v2优惠券秒杀方案对比](/posts/v1与v2优惠券秒杀方案对比)：秒杀场景同样面临热点数据访问问题

## 应用场景
- 面试被问"缓存击穿怎么解决"：不要只说"加锁"，要说出四级防御的递进逻辑
- 面试追问"万级请求同时击穿怎么办"：这是区分 P6 和 P7 的关键——tryLock + 分片锁

## 参考来源
- [第16小节-用户查询优惠券之缓存击穿](/posts/第16小节-用户查询优惠券之缓存击穿)
