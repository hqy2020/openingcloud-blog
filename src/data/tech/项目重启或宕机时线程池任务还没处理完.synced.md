---
title: "项目重启或宕机时线程池任务还没处理完"
description: "优雅关闭线程池和消息队列兜底两种方案保障任务不丢失"
date: 2026-02-11
category: tech
tags: [并发编程]
---

# 项目重启或宕机时线程池任务还没处理完？

## 回答话术

项目重启或宕机时，线程池中未完成的任务会丢失。两大解决方案：

1. **优雅关闭线程池**：适合任务量不大的场景。实现 Spring `DisposableBean` 接口，在应用关闭时调用 `shutdown()` 和 `awaitTermination()` 方法，等待线程池任务完成后再关闭应用。
2. **消息队列兜底**：适合批量任务场景。将任务投递到消息队列（如 RocketMQ）而非直接投递线程池，在消费端通过线程池处理。这样既能保障消息不丢失，又能提升消费速度。

## 问题详解

### 1. 优雅关闭线程池实现

```java
@Slf4j
@Service
public class TestThreadPoolService implements DisposableBean {
    private final ThreadPoolExecutor threadPoolExecutor =
        new ThreadPoolExecutor(10, 20, 1000, TimeUnit.MINUTES,
                               new LinkedBlockingQueue<>(4096));

    @Override
    public void destroy() throws Exception {
        threadPoolExecutor.shutdown();
        if (!threadPoolExecutor.awaitTermination(30, TimeUnit.SECONDS)) {
            log.warn("等待超时");
        }
        log.info("线程池优雅关闭成功");
    }
}
```

**三个关键技术点**：

#### 1.1 DisposableBean 接口作用
- Spring Bean 生命周期中的销毁回调接口
- 当应用收到 `kill -15` 优雅退出指令时被调用
- 触发时机：Tomcat 调用 `ServletContextListener#contextDestroyed()` -> Spring 开始销毁 Bean

#### 1.2 awaitTermination 方法机制
- 阻塞主线程，等待线程池中所有任务执行完成，直到等待超时或线程池终止
- 底层实现：通过 ReentrantLock 和条件变量（termination），循环检查线程池运行状态是否达到 TERMINATED

#### 1.3 为什么先调 shutdown() 再调 awaitTermination()
- 若不先调 `shutdown()`，线程池仍处运行状态，继续接收新任务
- `awaitTermination()` 可能永远无法返回成功
- 先 `shutdown()` 能使线程池进入关闭状态，停止接收新任务，等待已提交任务完成

### 2. 消息队列保障方案

**消息生产者**：

```java
@Service
public class TestThreadPoolService {
    private final RocketMQTemplate rocketMQTemplate;

    public void send() {
        List<String> phones = ...;
        for (String phone : phones) {
            Message<String> msg = MessageBuilder.withPayload(phone).build();
            rocketMQTemplate.syncSend("topic", msg);
        }
    }
}
```

**消息消费者**：

```java
@Component
@RocketMQMessageListener(topic = "topic", consumerGroup = "demo_consumer_group")
public class TestThreadPoolConsumer implements RocketMQListener<String> {
    private final ThreadPoolExecutor threadPoolExecutor =
        new ThreadPoolExecutor(4, 8, 1000, TimeUnit.MINUTES,
                               new SynchronousQueue<>());

    @Override
    public void onMessage(String phone) {
        threadPoolExecutor.execute(() -> {
            // 发送短信逻辑
        });
    }
}
```

**关键优化**：消费端线程池使用 `SynchronousQueue`（不设置队列长度），消费端也要实现优雅关闭逻辑。

### 3. 极端场景处理

- 投递线程池前将任务备份到数据库
- 线程池完成任务后标记为完成状态
- 定时扫描未完成任务，异步重新处理（最终一致性）

## 关键要点

- 优雅关闭适合任务量小、快速响应的场景，实现简单但任务多时仍可能丢失
- 消息队列适合批量任务、需可靠性的场景，保证不丢失但引入消息中间件增加复杂度
- `kill -15` 触发优雅关闭，`kill -9` 强制关闭不走优雅流程
- IDEA 点击关闭按钮等同 `kill -15`，快速连续点击等同 `kill -9`
